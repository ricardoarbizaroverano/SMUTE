<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Smute</title>

  <style>
    /* ====================== BASE STYLES ====================== */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      color: lime;
      font-family: 'Courier New', Courier, monospace;
      -webkit-text-size-adjust: none;
    }
    h1 {
      text-align: center;
      font-size: 3em;
      margin: 3rem 0 2rem; /* extra spacing to avoid overlap with nav */
    }

    /* ====================== NAVIGATION BAR ====================== */
    nav {
      position: fixed;
      top: 0;
      right: 0;
      background: black;
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 999;
      overflow-x: auto;
      max-width: 100%;
    }
    nav button {
      color: lime;
      background: transparent;
      border: 1px solid lime;
      font-size: 1em;
      padding: 5px 8px;
      border-radius: 4px;
      cursor: pointer;
      flex-shrink: 0;
    }
    nav button:hover {
      background: lime;
      color: black;
    }

    @media (max-width: 500px) {
      nav button {
        font-size: 0.9em;
        padding: 4px 6px;
      }
      h1 {
        font-size: 2em;
        margin-top: 4rem;
      }
    }

    /* ========== Content Sections ========== */
    .content {
      display: none;
      padding: 1rem;
      margin-top: 60px; /* offset below nav bar */
    }
    .content.active {
      display: block;
    }
    .page-title {
      text-align: center;
      margin-top: 1rem;
      font-size: 2.5em;
    }

    /* ========== Performance Mode Button ========== */
    .performance-mode {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: lime;
      color: black;
      border: none;
      padding: 10px;
      font-size: 1em;
      border-radius: 5px;
      cursor: pointer;
      z-index: 998;
    }
    .performance-mode:hover {
      background: black;
      color: lime;
      border: 1px solid lime;
    }

    /* ========== Mic & Monitoring Toggles ========== */
    .mic-toggle {
      position: fixed;
      bottom: 10px;
      right: 200px;
      background: lime;
      color: black;
      border: none;
      padding: 10px;
      font-size: 1em;
      border-radius: 5px;
      cursor: pointer;
      z-index: 998;
    }
    .mic-toggle.active {
      background: black;
      color: lime;
      border: 2px solid lime;
    }
    .monitoring-toggle {
      position: fixed;
      bottom: 10px;
      right: 360px;
      background: lime;
      color: black;
      border: none;
      padding: 8px;
      font-size: 0.9em;
      border-radius: 4px;
      cursor: pointer;
      width: 130px;
      text-align: center;
      z-index: 998;
    }
    .monitoring-toggle.off {
      background: black;
      color: lime;
      border: 2px solid lime;
    }

    /* =========== DRAG HANDLE & EDIT MODE =========== */
    .drag-handle {
      display: none; /* hidden unless .editable is applied */
      width: 100%;
      height: 20px;
      background: #444;
      color: #999;
      font-size: 0.7em;
      text-align: center;
      line-height: 20px;
      cursor: move;
      touch-action: none;
    }
    .editable .drag-handle {
      display: block; /* show drag handle in Edit Mode */
    }
    .editable {
      outline: 2px dashed lime;
      resize: both !important;
      overflow: auto !important;
    }

    /* ============= HOME PAGE ============= */
    #home h1 {
      margin-top: 20vh;
    }

    /* ============= LOOP PAGE ============= */
    .loop-button-item {
      position: absolute;
      width: 30vw;
      min-width: 100px;
      height: 20vh;
      min-height: 60px;
      background: lime;
      color: black;
      font-size: 1em;
      border-radius: 10px;
      overflow: hidden;
      z-index: 1;
    }
    .loop-button {
      width: 100%;
      height: calc(100% - 20px);
      border: none;
      background: black;
      color: lime;
      cursor: pointer;
      font-size: 1.2em;
      border-radius: 6px;
    }
    .loop-button:hover {
      background: lime;
      color: black;
    }

    /* ============= FX PAGE ============= */
    .fx-container {
      position: relative;
      width: 100%;
      height: 80vh;
      overflow: auto;
      margin-top: 2rem;
    }
    .fx-item, .slider-item {
      position: absolute;
      border-radius: 10px;
      overflow: hidden;
      z-index: 1;
    }
    .fx-item {
      width: 320px;
      min-width: 100px;
      height: 180px;
      min-height: 60px;
      background: lime;
      color: black;
      font-size: 1.5em;
    }
    .fx-button {
      width: 100%;
      height: calc(100% - 20px);
      border: none;
      background: transparent;
      color: black;
      font-size: 1em; 
      cursor: pointer;
      transition: background 0.2s, color 0.2s, box-shadow 0.2s;
    }
    .fx-button:hover {
      box-shadow: 0 0 8px lime;
    }
    .fx-button.active {
      background: black;
      color: lime;
      border: 2px solid lime;
      box-shadow: 0 0 10px 2px lime;
    }
    .slider-item {
      width: 200px;
      min-width: 100px;
      height: 50px;
      min-height: 50px;
      background: black;
    }
    .fx-slider {
      position: absolute;
      left: 0;
      top: 20px;
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
      width: 200px;  
      height: 30px;  
      cursor: pointer;
      touch-action: none;
    }

    /* =========== MIDI Output Dropdown =========== */
    #midiSelectContainer {
      position: fixed;
      bottom: 60px;
      right: 30px;
      background: black;
      border: 1px solid lime;
      padding: 6px;
      border-radius: 4px;
      z-index: 998;
    }
    #midiOutputs {
      font-size: 1em;
      background: #333;
      color: lime;
      border: 1px solid lime;
      border-radius: 4px;
    }

    /* ============= CONTROL PAGE ============= */
    .control-large-btn,
    .control-small-btn {
      position: absolute;
      background: #111; /* OFF by default => black */
      color: lime;
      border: 1px dashed lime;
      border-radius: 6px;
      overflow: hidden;
      z-index: 1;
    }
    .control-large-btn {
      width: 320px;
      height: 120px;
    }
    .control-small-btn {
      width: 140px;
      height: 60px;
    }
    .control-button-label {
      display: block;
      margin: 20px;
      text-align: center;
      font-size: 1em;
      font-weight: bold;
      color: lime;
    }
    .midi-slider {
      position: absolute;
      background: black;
      border: 2px solid lime;
      border-radius: 6px;
      padding: 10px;
      z-index: 1;
    }
    .midi-slider input[type="range"] {
      width: 100%;
      appearance: none;
      background: transparent;
    }
    .midi-slider input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      background: lime;
      border: 1px solid black;
    }
    .midi-slider input[type="range"]::-webkit-slider-thumb {
      width: 20px; 
      height: 20px;
      background: black;
      border: 2px solid lime;
      border-radius: 50%;
      appearance: none;
      margin-top: -7px;
      cursor: pointer;
    }
  </style>

  <script>
    /* ========================= SINGLE DECLARATIONS ========================= */
    let loopState = "idle";
    let recordedChunks = [];
    let loopAudio = null;

    let audioContext;
    let micStream;
    let gainNode;
    let delayNode;
    let convolver;
    let isMicActive = false;
    let isMonitoring = true;

    let isReverbActive = false; // OFF by default
    let isDelayActive = false;  // OFF by default

    /* MIDI Declarations */
    let midiAccess = null;
    let midiOutput = null;
    const midiChannel = 1; // default channel for CC messages

    /* Edit Mode Flag */
    let editMode = false;

    /* ========================== MIDI HELPER FUNCTIONS ========================== */
    function sendMIDIMessage(status, data1, data2) {
      if (midiOutput) {
        midiOutput.send([status, data1, data2]);
        console.log(`MIDI -> 0x${status.toString(16)} ${data1} ${data2}`);
      } else {
        console.warn("No MIDI Output selected");
      }
    }
    function sendMIDIControlChange(ccNumber, value) {
      const val = Math.max(0, Math.min(127, value));
      const status = 0xB0 + (midiChannel - 1);
      sendMIDIMessage(status, ccNumber, val);
    }

    async function initMIDI() {
      if (!navigator.requestMIDIAccess) {
        console.warn("Web MIDI API not supported.");
        return;
      }
      try {
        // Requests user authorization for MIDI
        midiAccess = await navigator.requestMIDIAccess();
        populateMIDIOutputs();
      } catch (e) {
        console.error("MIDI init failed:", e);
      }
    }

    function populateMIDIOutputs() {
      const outSelect = document.getElementById('midiOutputs');
      if (!midiAccess || !outSelect) return;
      outSelect.innerHTML = '';

      const outputs = Array.from(midiAccess.outputs.values());
      outputs.forEach(output => {
        const opt = document.createElement('option');
        opt.value = output.id;
        opt.textContent = output.name;
        outSelect.appendChild(opt);
      });

      // default: pick the first if present
      if (outSelect.options.length > 0) {
        outSelect.value = outSelect.options[0].value;
        midiOutput = midiAccess.outputs.get(outSelect.value);
      }

      outSelect.addEventListener('change', e => {
        const outID = e.target.value;
        midiOutput = midiAccess.outputs.get(outID);
        console.log("Selected MIDI output:", midiOutput ? midiOutput.name : "none");
      });
    }

    /* ========================= Microphone & Monitoring ========================= */
    async function toggleMic() {
      const micBtn = document.getElementById('mic-toggle');
      if (isMicActive) {
        if (micStream) micStream.disconnect();
        isMicActive = false;
        micBtn.classList.remove('active');
      } else {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation: true, noiseSuppression: true }
          });
          micStream = audioContext.createMediaStreamSource(stream);

          gainNode = audioContext.createGain();
          delayNode = audioContext.createDelay();
          convolver = audioContext.createConvolver();

          // Example impulse response
          const impulseResponse = await fetch('impulseWF_baptistchurch.wav')
            .then(res => res.arrayBuffer())
            .then(data => audioContext.decodeAudioData(data));
          convolver.buffer = impulseResponse;

          micStream.connect(gainNode).connect(audioContext.destination);
          gainNode.gain.value = isMonitoring ? 1 : 0;

          isMicActive = true;
          micBtn.classList.add('active');
        } catch (err) {
          console.error("Error accessing microphone:", err);
        }
      }
    }
    function toggleMonitoring() {
      const monBtn = document.getElementById('monitoring-toggle');
      isMonitoring = !isMonitoring;
      if (isMonitoring) {
        monBtn.textContent = "Monitoring On";
        monBtn.classList.remove('off');
      } else {
        monBtn.textContent = "Monitoring Off";
        monBtn.classList.add('off');
      }
      if (gainNode) {
        gainNode.gain.value = isMonitoring ? 1 : 0;
      }
    }

    /* ========================= FX: Reverb & Delay ========================= */
    function toggleReverb() {
      if (!audioContext) return;
      isReverbActive = !isReverbActive;
      const btn = document.getElementById('reverb-button');
      if (isReverbActive) {
        try { gainNode.disconnect(delayNode); } catch(e){}
        gainNode.connect(convolver).connect(delayNode).connect(audioContext.destination);
        btn.textContent = "Reverb: ON";
        btn.classList.add('active');
      } else {
        try { gainNode.disconnect(convolver); convolver.disconnect(delayNode);} catch(e){}
        gainNode.connect(delayNode).connect(audioContext.destination);
        btn.textContent = "Reverb: OFF";
        btn.classList.remove('active');
      }
    }
    function toggleDelay() {
      if (!audioContext) return;
      isDelayActive = !isDelayActive;
      const btn = document.getElementById('delay-button');
      if (isDelayActive) {
        delayNode.delayTime.value = 0.5;
        btn.textContent = "Delay: ON";
        btn.classList.add('active');
      } else {
        delayNode.delayTime.value = 0;
        btn.textContent = "Delay: OFF";
        btn.classList.remove('active');
      }
    }

    // Show reverb slider value
    function updateReverbLevel(value) {
      if (!convolver) return;
      convolver.normalize = (value > 50);

      let reverbVal = document.getElementById('reverbValue');
      if (!reverbVal) {
        reverbVal = document.createElement('div');
        reverbVal.id = 'reverbValue';
        reverbVal.style.position = 'absolute';
        reverbVal.style.left = '640px';
        reverbVal.style.top = '100px';
        reverbVal.style.color = 'lime';
        reverbVal.textContent = `Reverb Slider: ${value}`;
        document.getElementById('fx').appendChild(reverbVal);
      } else {
        reverbVal.textContent = `Reverb Slider: ${value}`;
      }
    }
    // Show delay slider value
    function updateDelayLevel(value) {
      if (!delayNode) return;
      delayNode.delayTime.value = value / 100;

      let delayVal = document.getElementById('delayValue');
      if (!delayVal) {
        delayVal = document.createElement('div');
        delayVal.id = 'delayValue';
        delayVal.style.position = 'absolute';
        delayVal.style.left = '640px';
        delayVal.style.top = '420px';
        delayVal.style.color = 'lime';
        delayVal.textContent = `Delay Slider: ${value}`;
        document.getElementById('fx').appendChild(delayVal);
      } else {
        delayVal.textContent = `Delay Slider: ${value}`;
      }
    }

    /* ========================= LOOPING & OVERDUB ========================= */
    function loopButtonPressed() {
      if (!micStream) {
        alert('Mic not active!');
        return;
      }
      switch(loopState) {
        case "idle":
          startRecording();
          loopState = "recording";
          updateLoopButtonAppearance("Recording", "#0f0", "#000");
          break;
        case "recording":
          stopRecordingAndPlay();
          loopState = "looping";
          updateLoopButtonAppearance("Playing", "#4f4", "#000");
          break;
        case "looping":
          startOverdub();
          loopState = "overdub";
          updateLoopButtonAppearance("Overdubbing", "#6f6", "#000");
          break;
        case "overdub":
          stopOverdub();
          loopState = "looping";
          updateLoopButtonAppearance("Playing", "#4f4", "#000");
          break;
      }
    }
    function updateLoopButtonAppearance(text, bgColor, textColor) {
      const loopBtnContainer = document.querySelector('.loop-button-item.editable');
      if (!loopBtnContainer) return;
      const btn = loopBtnContainer.querySelector('.loop-button');
      if (!btn) return;
      btn.textContent = text;
      btn.style.background = bgColor;
      btn.style.color = textColor;
    }

    let mediaRecorder;
    let layers = [];
    let currentLayerIndex = -1;

    function startRecording() {
      recordedChunks = [];
      const dest = audioContext.createMediaStreamDestination();
      micStream.connect(dest);
      mediaRecorder = new MediaRecorder(dest.stream);
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = onRecordingStop;
      mediaRecorder.start();
    }
    function stopRecordingAndPlay() {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    }
    function onRecordingStop() {
      const blob = new Blob(recordedChunks, { type: 'audio/webm; codecs=opus' });
      const url = URL.createObjectURL(blob);
      layers.push(url);
      currentLayerIndex = layers.length - 1;
      if (!loopAudio) {
        loopAudio = new Audio();
        loopAudio.loop = true;
      }
      loopAudio.src = url;
      loopAudio.play();
    }
    function startOverdub() {
      if (!loopAudio) {
        alert("No initial loop to overdub!");
        return;
      }
      recordedChunks = [];
      const dest = audioContext.createMediaStreamDestination();
      micStream.connect(dest);
      mediaRecorder = new MediaRecorder(dest.stream);
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = onOverdubStop;
      mediaRecorder.start();
    }
    function onOverdubStop() {
      const blob = new Blob(recordedChunks, { type: 'audio/webm; codecs=opus' });
      const url = URL.createObjectURL(blob);
      layers.push(url);
      currentLayerIndex = layers.length - 1;
      loopAudio.src = url;
      loopAudio.play();
    }
    function stopOverdub() {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    }
    function stopLoop() {
      if (loopAudio) {
        loopAudio.pause();
        loopAudio.currentTime = 0;
      }
      loopState = "idle";
      updateLoopButtonAppearance("LOOP", "black", "lime");
    }
    function backLayer() {
      if (layers.length === 0) return;
      currentLayerIndex = Math.max(0, currentLayerIndex - 1);
      const url = layers[currentLayerIndex];
      if (!loopAudio) {
        loopAudio = new Audio();
        loopAudio.loop = true;
      }
      loopAudio.src = url;
      loopAudio.play();
      loopState = "looping";
      updateLoopButtonAppearance("Playing", "#4f4", "#000");
    }

    /* ========================= EDIT MODE & DRAGGING ========================= */
    function toggleEditMode() {
      const btn = document.getElementById('edit-mode-toggle');
      editMode = !editMode;
      btn.textContent = editMode ? 'Edit Mode: ON' : 'Edit Mode: OFF';
      document.querySelectorAll(
        '.fx-item, .slider-item, .loop-button-item, .control-large-btn, .control-small-btn, .midi-slider'
      ).forEach(el => {
        if (editMode) el.classList.add('editable');
        else el.classList.remove('editable');
      });
    }

    let currentDraggable = null;
    let offsetX = 0, offsetY = 0;

    function handleDragStart(e) {
      if (!editMode) return;
      e.preventDefault();
      let clientX = e.clientX, clientY = e.clientY;
      if (!clientX && e.touches && e.touches[0]) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      }
      currentDraggable = e.currentTarget.parentElement;
      if (!currentDraggable) return;
      const rect = currentDraggable.getBoundingClientRect();
      offsetX = clientX - rect.left;
      offsetY = clientY - rect.top;

      document.addEventListener('mousemove', handleDragMove, {passive:false});
      document.addEventListener('mouseup', handleDragEnd);
      document.addEventListener('touchmove', handleDragMove, {passive:false});
      document.addEventListener('touchend', handleDragEnd);
    }

    function handleDragMove(e) {
      if (!currentDraggable) return;
      e.preventDefault();
      let clientX = e.clientX, clientY = e.clientY;
      if (!clientX && e.touches && e.touches[0]) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      }
      currentDraggable.style.left = (clientX - offsetX) + 'px';
      currentDraggable.style.top = (clientY - offsetY) + 'px';
    }

    function handleDragEnd(e) {
      e.preventDefault();
      document.removeEventListener('mousemove', handleDragMove);
      document.removeEventListener('mouseup', handleDragEnd);
      document.removeEventListener('touchmove', handleDragMove);
      document.removeEventListener('touchend', handleDragEnd);
      currentDraggable = null;
    }

    /* ========================= PERFORMANCE MODE ========================= */
    function enablePerformanceMode() {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        document.documentElement.requestFullscreen();
      }
    }

    /* ========================= PAGE SWITCHING ========================= */
    function switchPage(pageId) {
      document.querySelectorAll('.content').forEach(s => s.classList.remove('active'));
      document.getElementById(pageId).classList.add('active');
    }

    /* ========================= GYROSCOPE (Channels: X=10, Y=11, Z=12) ========================= */
    let gyroEnabled = false;
    let gyroListener = null;

    function toggleGyroCheckbox() {
      const check = document.getElementById('gyroCheck');
      if (!check) return;
      if (check.checked) startGyro();
      else stopGyro();
    }

    function startGyro() {
      if (gyroEnabled) return;
      gyroEnabled = true;
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(res => {
          if (res === 'granted') activateGyro();
          else {
            alert("Gyro permission denied.");
            const check = document.getElementById('gyroCheck');
            if (check) check.checked = false;
          }
        }).catch(err => console.error(err));
      } else {
        activateGyro();
      }
    }

    function activateGyro() {
      const disp = document.getElementById('gyroDisplay');
      gyroListener = (e) => {
        const alpha = e.alpha || 0; // X
        const beta  = e.beta  || 0; // Y
        const gamma = e.gamma || 0; // Z
        // scale each axis to 0..127
        const xVal = Math.floor((alpha / 360) * 127);
        const yVal = Math.floor(((beta + 180) / 360) * 127);
        const zVal = Math.floor(((gamma + 90) / 180) * 127);

        sendMIDIControlChange(10, xVal);
        sendMIDIControlChange(11, yVal);
        sendMIDIControlChange(12, zVal);

        if (disp) {
          disp.textContent = `Gyro X->CC10: ${xVal}\nGyro Y->CC11: ${yVal}\nGyro Z->CC12: ${zVal}`;
        }
      };
      window.addEventListener('deviceorientation', gyroListener);
    }

    function stopGyro() {
      gyroEnabled = false;
      if (gyroListener) window.removeEventListener('deviceorientation', gyroListener);
      const disp = document.getElementById('gyroDisplay');
      if (disp) disp.textContent = "Gyro OFF";
    }

    /* ========================= ON LOAD ========================= */
    window.onload = async () => {
      await initMIDI();

      // Mic & Monitoring toggles
      document.getElementById('mic-toggle').addEventListener('click', toggleMic);
      document.getElementById('monitoring-toggle').addEventListener('click', toggleMonitoring);

      // Reverb/Delay: OFF
      const reverbBtn = document.getElementById('reverb-button');
      if (reverbBtn) reverbBtn.textContent = "Reverb: OFF";
      const delayBtn = document.getElementById('delay-button');
      if (delayBtn) delayBtn.textContent = "Delay: OFF";

      // Attach drag handles
      document.querySelectorAll('.drag-handle').forEach(h => {
        h.addEventListener('mousedown', handleDragStart);
        h.addEventListener('touchstart', handleDragStart, {passive:false});
      });

      // Show reverb slider value on input
      const reverbSlider = document.getElementById('reverb-slider');
      if (reverbSlider) {
        reverbSlider.addEventListener('input', e => {
          const val = parseInt(e.target.value);
          updateReverbLevel(val);
        });
      }

      // Show delay slider value on input
      const delaySlider = document.getElementById('delay-slider');
      if (delaySlider) {
        delaySlider.addEventListener('input', e => {
          const val = parseInt(e.target.value);
          updateDelayLevel(val);
        });
      }

      // CONTROL MODE: Big/Small Buttons + Slider -> add toggles
      // Large1 = CC10
      let cc10On = false;
      const large1 = document.getElementById('ctrlLarge1');
      if (large1) {
        large1.addEventListener('click', () => {
          cc10On = !cc10On;
          if (cc10On) {
            large1.style.background = '#4f4';
            sendMIDIControlChange(10, 127);
            console.log("CC10 -> 127");
          } else {
            large1.style.background = '#111';
            sendMIDIControlChange(10, 0);
            console.log("CC10 -> 0");
          }
        });
      }
      // Large2 = CC11
      let cc11On = false;
      const large2 = document.getElementById('ctrlLarge2');
      if (large2) {
        large2.addEventListener('click', () => {
          cc11On = !cc11On;
          if (cc11On) {
            large2.style.background = '#4f4';
            sendMIDIControlChange(11, 127);
            console.log("CC11 -> 127");
          } else {
            large2.style.background = '#111';
            sendMIDIControlChange(11, 0);
            console.log("CC11 -> 0");
          }
        });
      }

      // Small1 = CC12
      let cc12On = false;
      const small1 = document.getElementById('ctrlSmall1');
      if (small1) {
        small1.addEventListener('click', () => {
          cc12On = !cc12On;
          if (cc12On) {
            small1.style.background = '#4f4';
            sendMIDIControlChange(12, 127);
            console.log("CC12 -> 127");
          } else {
            small1.style.background = '#111';
            sendMIDIControlChange(12, 0);
            console.log("CC12 -> 0");
          }
        });
      }

      // Small2 = CC13
      let cc13On = false;
      const small2 = document.getElementById('ctrlSmall2');
      if (small2) {
        small2.addEventListener('click', () => {
          cc13On = !cc13On;
          if (cc13On) {
            small2.style.background = '#4f4';
            sendMIDIControlChange(13, 127);
            console.log("CC13 -> 127");
          } else {
            small2.style.background = '#111';
            sendMIDIControlChange(13, 0);
            console.log("CC13 -> 0");
          }
        });
      }

      // Small3 = CC14
      let cc14On = false;
      const small3 = document.getElementById('ctrlSmall3');
      if (small3) {
        small3.addEventListener('click', () => {
          cc14On = !cc14On;
          if (cc14On) {
            small3.style.background = '#4f4';
            sendMIDIControlChange(14, 127);
            console.log("CC14 -> 127");
          } else {
            small3.style.background = '#111';
            sendMIDIControlChange(14, 0);
            console.log("CC14 -> 0");
          }
        });
      }

      // Control Slider = CC15
      const ctrlSlider = document.querySelector('#ctrlSlider input[type="range"]');
      if (ctrlSlider) {
        let sliderLabel = null;
        ctrlSlider.addEventListener('input', e => {
          const val = parseInt(e.target.value);
          sendMIDIControlChange(15, val);
          console.log(`CC15 -> ${val}`);

          // Display value below or near slider
          if (!sliderLabel) {
            sliderLabel = document.createElement('div');
            sliderLabel.id = 'ctrlSliderValue';
            sliderLabel.style.position = 'absolute';
            // place it under the slider
            sliderLabel.style.left = '1022.24px';
            sliderLabel.style.top = '580px'; 
            sliderLabel.style.color = 'lime';
            sliderLabel.textContent = `Slider CC15: ${val}`;
            document.getElementById('control').appendChild(sliderLabel);
          } else {
            sliderLabel.textContent = `Slider CC15: ${val}`;
          }
        });
      }
    };
  </script>
</head>

<body>
  <!-- ========== NAV BAR ========== -->
  <nav>
    <button onclick="switchPage('home')">Home</button>
    <button onclick="switchPage('loop')">Loop</button>
    <button onclick="switchPage('fx')">FX</button>
    <button onclick="switchPage('pitch')">Pitch</button>
    <button onclick="switchPage('control')">Control</button>
    <button id="edit-mode-toggle" onclick="toggleEditMode()">Edit Mode: OFF</button>
  </nav>

  <!-- Mic Toggle -->
  <button id="mic-toggle" class="mic-toggle">Mic On/Off</button>
  <!-- Monitoring Toggle -->
  <button id="monitoring-toggle" class="monitoring-toggle">Monitoring On</button>

  <!-- MIDI Output Select at bottom-right -->
  <div id="midiSelectContainer">
    <label for="midiOutputs">MIDI Out:</label>
    <select id="midiOutputs"></select>
  </div>

  <!-- ===== HOME PAGE ===== -->
  <div id="home" class="content active">
    <h1>Smute</h1>
  </div>

  <!-- ===== LOOP PAGE ===== -->
  <div id="loop" class="content">
    <h1 class="page-title" style="margin-bottom:1.5rem;">Loop Mode</h1>

    <!-- L O O P  B U T T O N -->
    <div class="loop-button-item editable" style="left: 20px; top: 200px;">
      <div class="drag-handle">drag</div>
      <button class="loop-button" style="background: black; color: lime;" onclick="loopButtonPressed()">LOOP</button>
    </div>

    <!-- STOP BUTTON -->
    <div id="stop-button-item" class="loop-button-item editable" style="left: 23.9915px; top: 444.98px;">
      <div class="drag-handle">drag</div>
      <button class="loop-button" onclick="stopLoop()">STOP</button>
    </div>

    <!-- BACK BUTTON -->
    <div id="back-button-item" class="loop-button-item editable" style="left: 19.9929px; top: 684.98px;">
      <div class="drag-handle">drag</div>
      <button class="loop-button" onclick="backLayer()">BACK</button>
    </div>

    <button class="performance-mode" onclick="enablePerformanceMode()">Performance Mode</button>
  </div>

  <!-- ===== FX PAGE ===== -->
  <div id="fx" class="content">
    <h1 class="page-title" style="margin-bottom:1.5rem;">FX Mode</h1>
    <div class="fx-container">
      <!-- Reverb Item -->
      <div id="reverb-item" class="fx-item editable" style="width: 324px; height: 347px;">
        <div class="drag-handle">drag</div>
        <button id="reverb-button" class="fx-button" onclick="toggleReverb()">Reverb: OFF</button>
      </div>

      <!-- Reverb Slider -->
      <div id="reverb-slider-item" class="slider-item editable" style="left: 414.955px; top: 90.892px; width: 208px; height: 147px;">
        <div class="drag-handle">drag</div>
        <input id="reverb-slider" type="range" min="0" max="100" value="50" class="fx-slider">
      </div>

      <!-- Delay Item -->
      <div id="delay-item" class="fx-item editable" style="left: 2.99432px; top: 373.966px; width: 324px; height: 354px;">
        <div class="drag-handle">drag</div>
        <button id="delay-button" class="fx-button" onclick="toggleDelay()">Delay: OFF</button>
      </div>

      <!-- Delay Slider -->
      <div id="delay-slider-item" class="slider-item editable" style="left: 421.967px; top: 473.935px; width: 190px; height: 139px;">
        <div class="drag-handle">drag</div>
        <input id="delay-slider" type="range" min="0" max="100" value="50" class="fx-slider">
      </div>
    </div>
    <button class="performance-mode" onclick="enablePerformanceMode()">Performance Mode</button>
  </div>

  <!-- ===== PITCH PAGE ===== -->
  <div id="pitch" class="content">
    <h1 class="page-title">Pitch Mode</h1>
    <button class="performance-mode" onclick="enablePerformanceMode()">Performance Mode</button>
  </div>

  <!-- ===== CONTROL PAGE ===== -->
  <div id="control" class="content">
    <h1 class="page-title" style="margin-bottom:1.5rem;">Control Mode</h1>

    <!-- Gyroscope checkbox & display -->
    <label id="gyroLabel" style="position:absolute; top:30px; left:30px;">
      <input id="gyroCheck" type="checkbox" style="transform: scale(1.3); margin-right:10px;" onclick="toggleGyroCheckbox()"/>
      Enable Gyroscope
    </label>
    <div id="gyroDisplay" style="position:absolute; top:70px; left:30px;">Gyro OFF</div>

    <!-- Large Buttons (OFF) -->
    <div id="ctrlLarge1" class="control-large-btn"
         style="left: 37px; top: 237px; background: #111; width: 385px; height: 317px;">
      <div class="drag-handle">drag</div>
      <span class="control-button-label">CC10</span>
    </div>

    <div id="ctrlLarge2" class="control-large-btn"
         style="left: 29.9943px; top: 586.996px; background: #111; width: 396px; height: 276px;">
      <div class="drag-handle">drag</div>
      <span class="control-button-label">CC11</span>
    </div>

    <!-- Small Buttons (OFF) -->
    <div id="ctrlSmall1" class="control-small-btn"
         style="left: 624.182px; top: 221px; background: #111; width: 240px; height: 182px;">
      <div class="drag-handle">drag</div>
      <span class="control-button-label">CC12</span>
    </div>

    <div id="ctrlSmall2" class="control-small-btn"
         style="left: 623.173px; top: 463.996px; background: #111; width: 248px; height: 164px;">
      <div class="drag-handle">drag</div>
      <span class="control-button-label">CC13</span>
    </div>

    <div id="ctrlSmall3" class="control-small-btn"
         style="left: 620.182px; top: 669px; background: #111; width: 256px; height: 200px;">
      <div class="drag-handle">drag</div>
      <span class="control-button-label">CC14</span>
    </div>

    <!-- Control Slider -->
    <div id="ctrlSlider" class="midi-slider"
         style="left: 1022.24px; top: 515.956px; width: 310px; height: 57px;">
      <div class="drag-handle">drag</div>
      <input type="range" min="0" max="127" />
    </div>

    <button class="performance-mode" onclick="enablePerformanceMode()">Performance Mode</button>
  </div>
</body>
</html>
